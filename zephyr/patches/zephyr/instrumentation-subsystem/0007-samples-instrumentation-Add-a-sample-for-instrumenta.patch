From da56f974720fc3a23c7e6142f8ea7164e09f32ba Mon Sep 17 00:00:00 2001
From: Gustavo Romero <gustavo.romero@linaro.org>
Date: Thu, 27 Apr 2023 19:04:38 +0000
Subject: [PATCH 7/7] samples: instrumentation: Add a sample for
 instrumentation subsys

Adds a sample to show the tracing and profiling features when the
instrumentation subsystem is enabled (CONFIG_INSTRUMENTATION=y).

The sample consists in two threads in ping-pong mode, taking turns to
execute loops that spend some CPU cycles. This allows a couple of
context switches and so to demonstrate tracing of thread scheduling
events.

The sample also has an example on how to capture and show traces and
profile info via the CLI tool zaru and also how to export the traces
so they can be loaded in the Perfetto Trace Viewer tool.

Signed-off-by: Gustavo Romero <gustavo.romero@linaro.org>
Signed-off-by: Kevin Townsend <kevin.townsend@linaro.org>
Signed-off-by: Maciej Sobkowski <msobkowski@antmicro.com>
---
 samples/subsys/instrumentation/CMakeLists.txt |   8 ++
 samples/subsys/instrumentation/README.rst     | 101 ++++++++++++++++++
 .../boards/b_u585i_iot02a.overlay             |  36 +++++++
 .../instrumentation/boards/mps2_an385.overlay |  34 ++++++
 samples/subsys/instrumentation/prj.conf       |   3 +
 samples/subsys/instrumentation/src/main.c     |  74 +++++++++++++
 6 files changed, 256 insertions(+)
 create mode 100644 samples/subsys/instrumentation/CMakeLists.txt
 create mode 100644 samples/subsys/instrumentation/README.rst
 create mode 100644 samples/subsys/instrumentation/boards/b_u585i_iot02a.overlay
 create mode 100644 samples/subsys/instrumentation/boards/mps2_an385.overlay
 create mode 100644 samples/subsys/instrumentation/prj.conf
 create mode 100644 samples/subsys/instrumentation/src/main.c

diff --git a/samples/subsys/instrumentation/CMakeLists.txt b/samples/subsys/instrumentation/CMakeLists.txt
new file mode 100644
index 00000000000..5a2607a8a62
--- /dev/null
+++ b/samples/subsys/instrumentation/CMakeLists.txt
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.20.0)
+
+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
+project(instrumentation)
+
+target_sources(app PRIVATE src/main.c)
diff --git a/samples/subsys/instrumentation/README.rst b/samples/subsys/instrumentation/README.rst
new file mode 100644
index 00000000000..60977d59bf8
--- /dev/null
+++ b/samples/subsys/instrumentation/README.rst
@@ -0,0 +1,101 @@
+.. zephyr:code-sample:: instrumentation
+   :name: Instrumentation
+
+   Demonstrate the instrumentation subsystem tracing and profiling features.
+
+Overview
+********
+
+This sample shows the instrumentation subsystem tracing and profiling
+features. It basically consists of two threads in a ping-pong mode, taking
+turns to execute loops that spend some CPU cycles.
+
+Requirements
+************
+
+UART console is required to run this sample.
+
+Building and Running
+********************
+
+Build and flash the sample as follows, changing ``mps2/an385`` for your
+board.
+
+.. zephyr-app-commands::
+   :zephyr-app: samples/subsys/instrumentation
+   :host-os: unix
+   :board: mps2/an385
+   :goals: build flash
+   :compact:
+
+Alternatively you can run this using QEMU:
+
+.. zephyr-app-commands::
+   :zephyr-app: samples/subsys/instrumentation
+   :host-os: unix
+   :board: mps2/an385
+   :goals: run
+   :gen-args: '-DQEMU_SOCKET=y'
+   :compact:
+
+After the sample is flashed to the target (or QEMU is running), it must be possible to
+collect and visualize traces and profiling info using the instrumentation CLI
+tool, :zephyr_file:`scripts/zaru.py`.
+
+.. note::
+   Please note, that this subsystem uses the ``retained_mem`` driver, hence it's necessary
+   to add the proper devicetree overlay for the target board. See
+   :zephyr_file:`./samples/subsys/instrumentation/boards/mps2_an385.overlay` for an example.
+
+Connect the board's UART port to the host device and
+run the :zephyr_file:`scripts/zaru.py` script on the host.
+
+Source the :zephyr_file:`zephyr-env.sh` file to set the ``ZEPHYR_BASE`` variable and get
+:zephyr_file:`scripts/zaru.py` in your PATH:
+
+.. code-block:: console
+
+   . zephyr-env.sh
+
+Check instrumentation status:
+
+.. code-block:: console
+
+   zaru.py status
+
+Set the tracing/profiling trigger; in this sample the function
+``get_sem_and_exec_function`` is the one interesting to allow the observation
+of context switches:
+
+.. code-block:: console
+
+   zaru.py trace -v -c get_sem_and_exec_function
+
+Reboot target so tracing/profiling at the location is effective:
+
+.. code-block:: console
+
+   zaru.py reboot
+
+Wait ~2 seconds so the sample finishes 2 rounds of ping-pong between ``main``
+and ``thread_A``, and get the traces:
+
+.. code-block:: console
+
+   zaru.py trace -v
+
+Get the profile:
+
+.. code-block:: console
+
+   zaru.py profile -v -n 10
+
+Or alternatively, export the traces to Perfetto (it's necessary
+to reboot because ``zaru.py trace`` dumped the buffer and it's now empty):
+
+.. code-block:: console
+
+   zaru.py reboot
+   zaru.py trace -v --perfetto --output perfetto_zephyr.json
+
+Then, go to http://perfetto.dev, Trace Viewer, and load ``perfetto_zephyr.json``.
diff --git a/samples/subsys/instrumentation/boards/b_u585i_iot02a.overlay b/samples/subsys/instrumentation/boards/b_u585i_iot02a.overlay
new file mode 100644
index 00000000000..ea28b2c8033
--- /dev/null
+++ b/samples/subsys/instrumentation/boards/b_u585i_iot02a.overlay
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2023 Linaro
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <common/mem.h>
+
+/ {
+	sram@200bf000 {
+		compatible = "zephyr,memory-region", "mmio-sram";
+		reg = <0x200bf000 0x20>;
+		zephyr,memory-region = "RetainedMem";
+		status = "okay";
+
+		retainedmem {
+			compatible = "zephyr,retained-ram";
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			instrumentation_triggers: retention@0 {
+				compatible = "zephyr,retention";
+				status = "okay";
+
+				reg = <0x0 0x20>;
+
+				prefix = [be ef];
+			};
+		};
+	};
+};
+
+&sram0 {
+	reg = <0x20000000 DT_SIZE_K(764)>;
+};
diff --git a/samples/subsys/instrumentation/boards/mps2_an385.overlay b/samples/subsys/instrumentation/boards/mps2_an385.overlay
new file mode 100644
index 00000000000..adccb6d4490
--- /dev/null
+++ b/samples/subsys/instrumentation/boards/mps2_an385.overlay
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2023 Linaro
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/ {
+	sram@203fffe0 {
+		compatible = "zephyr,memory-region", "mmio-sram";
+		reg = <0x203fffe0 0x20>;
+		zephyr,memory-region = "RetainedMem";
+		status = "okay";
+
+		retainedmem {
+			compatible = "zephyr,retained-ram";
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			instrumentation_triggers: retention@0 {
+				compatible = "zephyr,retention";
+				status = "okay";
+
+				reg = <0x0 0x20>;
+
+				prefix = [be ef];
+			};
+		};
+	};
+};
+
+&sram0 {
+	reg = <0x20000000 0x3FFFE0>;
+};
diff --git a/samples/subsys/instrumentation/prj.conf b/samples/subsys/instrumentation/prj.conf
new file mode 100644
index 00000000000..27f4f40e814
--- /dev/null
+++ b/samples/subsys/instrumentation/prj.conf
@@ -0,0 +1,3 @@
+CONFIG_INSTRUMENTATION=y
+CONFIG_MAIN_STACK_SIZE=4096
+CONFIG_TIMESLICE_SIZE=0
diff --git a/samples/subsys/instrumentation/src/main.c b/samples/subsys/instrumentation/src/main.c
new file mode 100644
index 00000000000..7b2d752976f
--- /dev/null
+++ b/samples/subsys/instrumentation/src/main.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2023 Linaro
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/kernel.h>
+#include <zephyr/instrumentation/instrumentation.h>
+
+#define SLEEPTIME 10
+#define STACKSIZE 1024
+#define PRIORITY  7
+
+void __no_optimization loop_0(void)
+{
+	/* Wait to spend some cycles */
+	k_busy_wait(10);
+}
+
+void __no_optimization loop_1(void)
+{
+	/* Wait to spend some cycles */
+	k_busy_wait(1000);
+}
+
+/*
+ * 'main' thread can take its mutex promptly and run. 'thread_A' needs to wait 'main' give its
+ * (thread_A) mutex to run.
+ */
+K_SEM_DEFINE(main_sem, 1, 1);		/* Initialized as ready to be taken */
+K_SEM_DEFINE(thread_a_sem, 0, 1);	/* Initialized as already taken (blocked) */
+
+K_THREAD_STACK_DEFINE(thread_a_stack, STACKSIZE);
+static struct k_thread thread_a_data;
+
+static int counter;
+
+void get_sem_and_exec_function(struct k_sem *my_sem, struct k_sem *other_sem, void (*func)(void))
+{
+	while (counter < 4) {
+		k_sem_take(my_sem, K_FOREVER);
+
+		func();
+		k_msleep(SLEEPTIME);
+
+		counter++;
+		k_sem_give(other_sem);
+	}
+}
+
+void thread_A(void *notused0, void *notused1, void *notused2)
+{
+	ARG_UNUSED(notused0);
+	ARG_UNUSED(notused1);
+	ARG_UNUSED(notused2);
+
+	get_sem_and_exec_function(&thread_a_sem, &main_sem, loop_0);
+}
+
+int main(void)
+{
+	k_tid_t thread_a;
+
+	/* Create Thread A */
+	thread_a = k_thread_create(&thread_a_data, thread_a_stack, STACKSIZE, thread_A, NULL, NULL,
+			NULL, PRIORITY, 0, K_NO_WAIT);
+
+	k_thread_name_set(thread_a, "thread_A");
+
+	/* Start ping-pong between 'main' and 'thread_A' */
+	get_sem_and_exec_function(&main_sem, &thread_a_sem, loop_1);
+
+	return 0;
+}
-- 
2.50.0

